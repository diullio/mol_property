import os
import logging
import tqdm
import faiss
import bitarray
import numpy as np

import pandas as pd
from rdkit import Chem
from rdkit.Chem import DataStructs, rdMolDescriptors

cur_dir = os.path.dirname(__file__)


class HammingSS(object):

    """ Similarity Search based on Hamming Distance """

    def __init__(self,
                 zinc_file=os.path.join(cur_dir, "save/standard_csv.zip"),
                 index_file=os.path.join(cur_dir, "save/hamming.index")):
        self.df_zinc = pd.read_csv(zinc_file, compression="zip")
        self.index = self.load_index(index_file)

    def load_index(self, index_file):
        logging.info("load index from {}".format(index_file))
        return faiss.read_index_binary(index_file)
    
    @classmethod
    def build_index(cls, feature_file, index_file):
        '''
        :params feature_file: a npy file generated by using utils.build_mol_features
        '''
        logging.info("rebuild index from {}".format(feature_file))
        fp_arr = np.load(feature_file)
        bytes_list = []
        for item in tqdm.tqdm(fp_arr):
            bytes_list.append(cls.vec2bytes(item))
        dim = int(np.ceil(fp_arr.shape[1] / 8) * 8)
        index = faiss.IndexBinaryFlat(dim)
        index.add(np.array(bytes_list).astype("uint8"))
        faiss.write_index_binary(index, index_file)
        return index

    def search_by_mols(self, mols, topk=10):
        '''
        :param mols: a list of molecuar
        :param topk:
        :return: [[{"id": xx, "smiles": xx, "score": xx}, {}, ...], []]
        '''
        mols_vec = []
        for mol in mols:
            tmp_arr = np.array([])
            DataStructs.ConvertToNumpyArray(rdMolDescriptors.GetMACCSKeysFingerprint(mol), tmp_arr)
            mols_vec.append(self.vec2bytes(tmp_arr))
        ret_dists, ret_ids = self.index.search(np.array(mols_vec).astype("uint8"), topk)
        rets = []
        for mol, dists, ids in zip(mols, ret_dists, ret_ids):
            ret = []
            for id in ids:
                ret.append({"id": self.df_zinc.iloc[id]["zinc_id"],
                            "smiles": self.df_zinc.iloc[id]["smiles"],
                            "score": self.calc_similarity(
                                mol, Chem.MolFromSmiles(self.df_zinc.iloc[id]["smiles"]))})
        rets.append(sorted(ret, key=lambda item: item["score"], reverse=True))
        return rets

    @classmethod
    def vec2bytes(cls, vec):
        return list(bitarray.bitarray(list(vec)).tobytes())

    def calc_similarity(self, mol1, mol2):
        fp_mol1 = rdMolDescriptors.GetMACCSKeysFingerprint(mol1)
        fp_mol2 = rdMolDescriptors.GetMACCSKeysFingerprint(mol2)
        score = DataStructs.TanimotoSimilarity(fp_mol1, fp_mol2)
        return score


if __name__ == "__main__":
    hs = HammingSS()
    test_smiles = "C#C[C@H](OC(N)=O)c1ccccc1"
    import time
    start_time = time.time()
    rets = hs.search_by_mols([Chem.MolFromSmiles(test_smiles)])
    print("time:", time.time() - start_time)
    print(rets)

